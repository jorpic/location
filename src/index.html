<!DOCTYPE html>
<html>
  <head>
    <title>− Определение местоположения</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        display: flex;
        flex-flow: column;
        height: 100vh;
        max-width: 60rem;
        margin: auto;
      }
      header {
        display: flex;
        flex-flow: row wrap;
        justify-content: space-between;
        align-items: center;
        border: 1px solid green;
        padding: 0.5em;
      }
      @media (orientation: portrait) {
        header * {
          margin: 0.5em 1em;
        }
        header button {
          max-width: 40%;
        }
        header .info {
          order: 1;
          width: 100%;
        }
      }
      content {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-grow: 1;
        border: 1px solid red;
      }
    </style>
  </head>
  <body>
      <header>
        <h1>VW</h1>
        <p class="info">Помощь на дорогах</p>
        <button>Отправить координаты</button>
      </header>
      <content>
        <svg id="svg" width="100%" height="100%">
          <g id="map"></g>
          <g id="pin">
            <g transform="translate(-12 -36) scale(0.5)" fill="#880096">
              <path d="M24,0 C11,0 0,10 0,22 C0,35 10,50 24,72 C37,50 48,35 48,22 C48,10 36,0 24,0 L24,0 Z M24,33 C19,33 15,28 15,24 C15,19 19,15 24,15 C28,15 33,19 33,24 C33,28 28,33 24,33 L24,33 Z"></path>
            </g>
          </g>
        </svg>
      </content>
    <script>
      const $ = id => document.getElementById(id);
      const info = $("info");
      const svg = $("svg");


      const zoom = 16;
      const zPow = Math.pow(2, zoom-1);
      const tileSize = 255;
      const pi = Math.PI;

      function deg2tile({lon, lat}) {
        const lrad = lat * Math.PI / 180;
        let x = (lon + 180) / 180 * zPow;
        let y = (1 - Math.log(Math.tan(lrad) + 1/Math.cos(lrad))/pi) * zPow;
        return {x, y};
      }

      function tile2deg({x, y}) {
        const lon = 180 * (x / zPow - 1);
        const lat = Math.atan(Math.sinh(pi*(1 - y/zPow))) * 180 / pi;
        return {lon, lat};
      }

      const map = {
        el: $("map"),
        pin: $("pin"),
        dx: 0,
        dy: 0,
      };

      // center of the viewBox
      const cx = Math.floor((svg.clientWidth) / 2);
      const cy = Math.floor((svg.clientHeight) / 2);

      function initMap(pos) {
        const {x, y} = deg2tile(pos);
        const tx = Math.floor(x);
        const ty = Math.floor(y);

        // Add tiles.
        for(let i of [-1, 0]) {
          for(let j of [-1, 0]) {
            const img = document.createElementNS("http://www.w3.org/2000/svg", "image");
            const srv = "abc"[Math.floor(Math.random()*12)%3];
            // `xlink:href` is deprecated but we use it anyway as SVG2-style
            // `href` is not supported by iOS 11 and Safari 11.
            img.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              `https://${srv}.tile.openstreetmap.org/${zoom}/${tx+i}/${ty+j}.png`);

            img.setAttribute("x", tileSize*i);
            img.setAttribute("y", tileSize*j);
            map.el.appendChild(img);
          }
        }

        map.pin.setAttribute("transform", `translate(${cx} ${cy})`);
        moveMap(tileSize * (x - tx), tileSize * (y - ty));
      }


      function moveMap(dx, dy) { // in pixels
        map.dx += dx;
        map.dy += dy;

        map.el.setAttribute("transform", `translate(${cx - map.dx} ${cy - map.dy})`);
        console.log(map);
        // calculate tile (x,y)
        // update info
      }


      function initTouch() {
        const pos = e => e.touches ? e.touches[0] : e;
        let isMoving = false;
        let sx, sy;

        function start(e) {
          e.preventDefault();
          isMoving = true;
          const p = pos(e);
          sx = p.pageX;
          sy = p.pageY;
        }

        function move(e) {
          if(isMoving) {
            const p = pos(e);
            moveMap(sx - p.pageX, sy - p.pageY);
            sx = p.pageX;
            sy = p.pageY;
            // info.textContent = ` TODO`;
          }
        }

        function end(e) {
          isMoving = false;
        }

        const listen = (el, ev, fn) => el.addEventListener(ev, fn, false);
        listen(svg, "mousedown", start);
        listen(svg, "touchstart", start);
        listen(svg, "mousemove", move);
        listen(svg, "touchmove", move);
        listen(document.body, "mouseup", end);
        // touchend is not required
      }


      function success(pos) {
        const res = {
          lat: pos.coords.latitude,
          lon: pos.coords.longitude,
          accuracy: pos.coords.accuracy,
          locationAge: new Date() - pos.timestamp,
          currentTime: Date.now(),
        }
        // `Ваши координаты: (${res.lat}, ${res.lon}) с точностью ±z метров.`;
      }

      function error(err) {
        console.log(err);
        info.textContent = "Не удалось определить координаты: " + err.message;
      }

      initMap({lat: 55.583357, lon: 37.596508});
      initTouch();

      // navigator.geolocation.getCurrentPosition(success, error);
    </script>
  </body>
</html>
